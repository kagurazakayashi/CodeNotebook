- ds，cs，ss都是汇编中的段寄存器而ip状态与控制寄存器。
- sp为索引寄存器，cs与ip搭配使用，ss与sp搭配使用；
- 虽然ds，cs，ss都是段寄存器但是他们的作用却大不相同，（基于8086CPU）

# 1. ds (Data Segment) 数据段寄存器
- 当我们想读取一个指定的内存单元上的数据时，我们可以通过把数据所在的内存段地址放入到ds寄存器中去，然后读取或者写入数据时就可以通过该ds寄存器内的段地址偏移得到我们的数据，或者偏移后写入数据
- 例如，我们现在想读取1000:0这个地址上的数据并且往1000:1这个地址写入一个数据时：
```
mov ax,1000   ;把1000这个段地址写入到ax这个通用寄存器中
mov ds,ax	  ;把ax中的段地址1000送入ds数据寄存器
mov bx,[0]	  ;把1000这个段地址偏移0位即1000：0地址上的内容读取到bx寄存器去
mov cx,2020	  ;把2020这个数据送入到cx寄存器
mov [1],cx	  ;最后把cx寄存器中的内容送入1000段地址偏移1位即1000：0001地址去
```
- 注：不能直接把数据送入到ds寄存器，因此需要先把数据送入一个通用寄存器再送入数据段寄存器

# 2. cs（代码段寄存器）与 ip（指令指针寄存器）
- 当我们想要声明一段内存单元为代码段让CPU去执行我们代码段里的指令或者代码时，因为指令和代码都是存放在内存单元中的；因此我们需要告诉CPU一个地址，让它去执行该地址的内存单元中的指令或代码；
- 其中：
    - `cs (Code Segment)` 是用于存放我们指令所在的段地址
    - `ip (Instruction Pointer)` 寄存器是用于存放指令所在的地址的偏移地址
    - 注：因为8086CPU是16位的，但是物理地址是20位的，它内存的寄存器只能表现16位的地址，因此使用了ip寄存器来存放偏移地址
- 在我们想要执行1000:0123地址上的一个指令时，则先修改cs与ip的值：
    - 通过r来修改寄存器的内容
        - `r cs`  回车输入段地址`1000`
        - `r ip`  回车输入偏移地址
```
-r cs
CS 1000  -> 原来CS的值下一行为修改的段地址
:1000
-r ip
IP 0003  -> 原来ip的值
:0123
-
```

# 3. ss（栈寄存器）与 sp（栈指针寄存器）
- 我们知道栈是后进先出（last in frist out）的且始终有一个栈顶指针指向栈顶的，当栈内无元素时，栈顶指针指向的是栈底；我们来讲一下汇编中的栈是怎样的：
- CPU中设置了两个两个寄存器用于存放栈顶的段地址与偏移地址，分别为：
    - `ss (Stack Segment)`：用于存放栈顶的段地址
    - `sp (Stack Pointer)`：用于栈顶的偏移地址
- 其中入栈的步骤分为两步：
- 入栈汇编指令： `push 寄存器名` -> 把寄存器中的值入栈
    1. `sp = sp - 2`
    2. 然后把入栈的寄存器内的数据放入栈的内存单元中
- 出栈的顺序也是分为两步：
- 出栈汇编指令： `pop 寄存器名` -> 把栈顶元素出栈保存到寄存器中
    1. sp = sp + 2
    2. 把该内存单元中的数据送到出栈的寄存器中
- 注：入栈与出栈都是按一个寄存器即一个字（两个字节）来入栈或出栈的（8086是16位的结构）

**注**
1. 为什么是 sp 偏移地址 加2 减2 呢
因为 `push` 与 `pop` 汇编指令执行是占两个字节的
2. 当栈为空时，当栈为空时，栈顶指针指向栈底内存单元地址+2（因为入栈时会先减2）

- 例如：`1000:0 - 1000:000f`为栈内存，空栈时，栈的偏移地址sp为多少？
- 答案：因为此时空栈，栈底的字内存单元地址为`000e`，加2即是`0010`

- 还有一种情况，栈的内存单元地址是`1000:0 - 1000:ffff`；空栈时，偏移地址sp为多少？
- 答案：此时空栈的栈底字内存单元为为fffe，加2即时空栈时的栈顶地址；此时加后为10000，只能存放16位，因此剩下0000；此时满栈与空栈的偏移地址均为0
- (地址从上到下是上面低位到下面高位的)

- 在指定的内存输入指令测试入栈与出栈：
```
;把bx、cx入栈到1000:0 - 1000:f 这段内存中去
mov ax,1000
mov ss,ax
mov sp,0
;把数据送入bx、cx寄存器
mov bx,1234
mov cx,4567
;入栈
push bx
push cx
;出栈，后进先出；cx会先出
pop bx	;会把cx放到bx中
pop cx
```

- 当我们想指定一段内存单元为栈时，因为8086CPU中没有预防我们栈溢出（超出栈内存继续入栈或出栈）问题；因此我们使用时需要小心使用，不要访问到其他内存单元去；而且尽量不要把ds，cs，ss同时使用一片内存
- 其实这个数据段，代码段和栈都是我们人为给他们指定的，我们可以同时把一段连续的内存分别指定为数据段、代码段和栈（但尽量不要这样做）；在CPU中它看到的只是一个完整的逻辑单元

<!-- https://blog.csdn.net/takashi77/article/details/108927861 -->