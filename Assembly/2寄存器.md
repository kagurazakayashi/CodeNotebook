# 第2章 寄存器
- CPU 概述
  - 一个典型的 CPU 由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。
  - 内部总线实现 CPU 内部各个器件之间的联系。
  - 外部总线实现 CPU 和主板上其它器件的联系。
- 寄存器概述
  - 8086 CPU 有 14 个寄存器 它们的名称为：`AX`、`BX`、`CX`、`DX`、`SI`、`DI`、`SP`、`BP`、`IP`、`CS`、`SS`、`DS`、`ES`、`PSW`。

## 2.1 通用寄存器
- 8086 CPU 所有的寄存器都是 16 位的，可以存放 2 个字节。
- `AX`、`BX`、`CX`、`DX` 通常用来存放一般性数据被称为通用寄存器。
- 下面以`AX`为例，寄存器的逻辑结构:
```
               16 位寄存器的逻辑结构
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
```
- 一个16位寄存器可以存储一个16位的数据。
```
           16位数据在寄存器中的存放情况

数据：18    二进制表示：10010    在寄存器AX中的存储：
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 1| 0| 0| 1| 0|

数据：20000    二进制表示：0100111000100000
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
| 0| 1| 0| 0| 1| 1| 1| 0| 0| 0| 1| 0| 0| 0| 0| 0|
```
- 一个16位寄存器所能存储的数据的最大值为：
  - `2^16-1`

- 8086 上一代 CPU 中的寄存器都是 8 位的；
- 为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。
  - `AX` 可以分为 `AH`(高位) 和 `AL`(低位) ；
  - `BX` 可以分为 `BH`(高位) 和 `BL`(低位) ；
  - `CX` 可以分为 `CH`(高位) 和 `CL`(低位) ；
  - `DX` 可以分为 `DH`(高位) 和 `DL`(低位) 。
- 8086 CPU 的 8 位寄存器存储逻辑
- 以AX为例，8086CPU的16位寄存器分为两个8位寄存器的情况：
```
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
  7  6  5  4  3  2  1  0  7  6  5  4  3  2  1  0
[          AH          ]|[          AL          ]
```

- AX的低8位（0位~7位）构成了AL寄存器，高8位（8位~15位）构成了AH寄存器。
- AH和AL寄存器是可以独立使用的8位寄存器。
- 一个8位寄存器所能存储的数据：
  - `2^8-1`
- 8086CPU的8位寄存器数据存储情况:
```
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
| 0| 1| 0| 0| 1| 1| 1| 0| 0| 0| 1| 0| 0| 0| 0| 0|
  7  6  5  4  3  2  1  0  7  6  5  4  3  2  1  0
[          AH          ]|[          AL          ]
```
| 寄存器 | 寄存器中的数据 | 所表示的值 |
| -- | ---------------: | :-----------: |
| AX | 0100111000100000 | 20000 (4E20H) |
| AH |     01001110     |    78 (4EH)   |
| AL |     00100000     |    32 (20H)   |

## 2.2 字在寄存器中的存储
一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。
```
字： (H 高位字节   L 低位字节)
0 1 0 0 1 1 1 0 0 0 1 0 0 0 0 0
[      H      ] [      L      ]
```

关于数制的讨论：
- 由于一个内存单元可以存放 8 位数据，CPU中的寄存器又可存放 n 个 8 位数据。也就是说，计算机中的数据大多是由 1~N 个 8 位数据构成的。
- 用十六进制来表示数据可以直观的看出这个数据是由哪些 8 位数据构成的。

## 2.3 几条汇编指令

**汇编指令不区分大小写**

常用汇编指令
- 汇编指令： `mov ax,18`
  - 控制CPU完成的操作： 将 8 送入 AX
  - 用高级语言语法表述： `AX = 18`
- 汇编指令： `mov ah,78`
  - 控制CPU完成的操作： 将 78 送入 AH
  - 用高级语言语法表述： `AH = 18`
- 汇编指令： `add ax,8`
  - 控制CPU完成的操作： 将寄存器 AX 中的数值加上 8
  - 用高级语言语法表述： `AX = AX + 8`
- 汇编指令： `mov ax,bx`
  - 控制CPU完成的操作： 将寄存器 BX 中的数据送入寄存器 AX
  - 用高级语言语法表述： `AX = BX`
- 汇编指令： `add ax,bx`
  - 控制CPU完成的操作： 将 AX, BX 中的内容相加，结果存在 AX 中
  - 用高级语言语法表述： `AX = AX + BX`

- CPU执行下表中的程序段的每条指令后，对寄存器中的数据进行的改变。
- `H` 是 16 进制， `B` 是 2 进制， 没有是 10 进制

- 程序段中指令执行情况之一
  - 原 AX 中的值：`0000H`，原 BX 中的值：`0000H`

| 0 | 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| - | :------------: | :-----: | :-----: |
| 1 | `mov ax,4E20H` | `4E20H` | `0000H` |
| 2 | `add ax,1406H` | `6226H` | `0000H` |
| 3 | `mov bx,2000H` | `6226H` | `2000H` |
| 4 | `add ax,bx`    | `8226H` | `2000H` |
| 5 | `mov bx,ax`    | `8226H` | `8226H` |
| 6 | `add ax,bx`    |    ?    | `8226H` |

```
求解过程
1. ax = 4E20H
2. ax = 1406H + 4E20H = 6226H
3. bx = 2000H
4. ax = ax (6226H) + bx (2000H) = 8226H
5. bx = ax (8226H)
6. ax = ax (8226H) + bx (8226H) = 1044CH
? = 044CH
```

- 程序段中指令执行情况之二
  - 原 AX 中的值：`0000H`，原 BX 中的值：`0000H`

| 0 | 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| - | :------------: | :-----: | :-----: |
| 1 | `mov ax,001AH` | `001AH` | `0000H` |
| 2 | `mov bx,0026H` | `001AH` | `0026H` |
| 3 | `add al,bl`    | `0040H` | `0026H` |
| 4 | `add ah,bl`    | `2640H` | `0026H` |
| 5 | `add bh,al`    | `2640H` | `4026H` |
| 6 | `mov ah,0`     | `0040H` | `4026H` |
| 7 | `add al,85H`   | `00C5H` | `4026H` |
| 8 | `add al,93H`   |    ?    | `4026H` |

```
AX = 00C5, AH = 00, AL = C5
求解过程
1. ax = 001AH
2. bx = 0026H
3. al = al (1AH) + bl (26H) = 40H, AX = 0040H
4. ah = ah (00H) + bl (26H) = 26H, AX = 2640H
5. bh = bh (00H) + al (40H) = 40H, BX = 4026H
6. ah = 00 40 H
7. al = al (40H) + 85H = C5H, AX = 00C5H
8. al = al (C5H) + 93H = 158H -> 58H, AX = 0058H
```

- 这里的丢失，指的是进位制不能在 8 位寄存器中保存，但是 CPU 不是并真的不丢弃 这个进位值，这个问题会在后面的课程中讨论。

## 2.4 物理地址
- CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。
- 每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地址。

## 2.5 16位结构的CPU
概括的讲，16位结构描述了一个CPU具有以下几个方面特征：
1. 运算器一次最多可以处理16位的数据。
2. 寄存器的最大宽度为16位。
3. 寄存器和运算器之间的通路是16位的。

## 2.6 8086CPU给出物理地址的方法
- 8086有20位地址总线，可传送20位地址，寻址能力为1M。
- 8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K。
- 8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。
- 地址加法器合成物理地址的方法： `物理地址 = 段地址 × 16 + 偏移地址`
  - 例如：8086CPU访问地址为123C8H的内存单元
    - 123 x 16 = 1230 + 00C8
- 由段地址×16引发的讨论:

| 移位位数 | 二进制 | 十六进制 | 十进制 |
| --- | ---------: | ----: | ---: |
| `0` | `    10 B` | ` 2H` | ` 2` |
| `1` | `   100 B` | ` 4H` | ` 4` |
| `2` | `  1000 B` | ` 8H` | ` 8` |
| `3` | ` 10000 B` | `10H` | `16` |
| `4` | `100000 B` | `20H` | `32` |

观察移位次数和各种形式数据的关系：
1. 一个数据的二进制形式左移1位，相当于该数据乘以2；
2. 一个数据的二进制形式左移N位，相当于该数据乘以2的N次方；
3. 地址加法器如何完成段地址×16的运算？**以二进制形式存放的段地址左移4位。**

## 2.7 `段地址 × 16 + 偏移地址 = 物理地址` 的本质含义
两个比喻说明：
- 说明 `基础地址 + 偏移地址 = 物理地址` 的思想：第一个比喻
- 说明 `段地址 × 16 + 偏移地址 = 物理地址` 的思想：第二个比喻
  - 8086CPU就是这样一个只能提供两张3位数据纸条的CPU。

### `基础地址 + 偏移地址 = 物理地址`
```
学校                 体育馆         图书馆
 |_____________________|_____________|
0 m                  2000 m        2826 m
```
- 比如说，学校、体育馆同在一条笔直的单行路上（学校位于路的起点`0m`处）。
- 读者在学校，要去图书馆，问我那里的地址，我可以用几种方式描述这个地址？
  1. 从学校走`2826m`到图书馆。这`2826`可以认为是图书馆的物理地址。
  2. 从学校走`2000m`到体育馆，从体育馆再走`826m`到图书馆。
    - 第一个距离`2000m`是相对于起点的基础地址；
    - 第二个距离`826m`是将对于基础地址的偏移地址。

### `段地址 × 16 + 偏移地址 = 物理地址`
- 比如我们只能通过纸条来通信，读者问我图书馆的地址，我只能将它写在纸上告诉读者。
- 显然我必须有一张可以容纳 `4` 位数据的纸条才能写下 `2826` 这个数据：
  - `| 2 | 8 | 2 | 6 |`
- 不巧的是，没有能容纳4位数据的纸条，仅有两张可以容纳3位数据的纸条。
  - 这样我只能以这种方式告诉读者2826这个数据：
    - `| 2 | 0 | 0 |`
    - `| 8 | 2 | 6 |`

## 2.8 段的概念
- 错误认识：
  - 内存被划分成了一个一个的段，每一个段有一个段地址。
- 其实：
  - 内存并没有分段，段的划分来自于CPU，由于8086CPU用 `(段地址 × 16) + 偏移地址 = 物理地址` 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

```
[        ]
[ 10000H ] ---------------
[        ]
[        ] 10000H ~ 100FFH
[  ....  ] 单元组成一个段
[        ]
[        ]
[ 100FFH ] ---------------
[        ]
```
- 我们可以认为：地址`10000H ~ 100FFH`的内存单元组成一个段，该段的起始地址（ 基础地址）为`10000H`，段地址为`1000H`，大小为`100H`。

```
[        ]
[ 10000H ] ---------------
[        ] 10000H ~ 1007FH
[        ] 单元组成一个段
[ 1007FH ] ---------------
[ 10080H ] ---------------
[        ] 10080H ~ 100FFH
[        ] 单元组成一个段
[ 100FFH ] ---------------
[        ]
```
- 我们也可以认为地址`10000H~1007FH`、`10080H~100FFH`的内存单元组成两个段，它们的起始地址（ 基础地址 ）为`10000H`和`10080H`，段地址为：`1000H`和`1008H`，大小都为`80H`。

以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。
- 两点需要注意
  1. 段地址×16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数；
  2. 偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。

### 内存单元地址小结
- CPU访问内存单元时，必须向内存提供内存单元的物理地址。
- 8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。
- CPU可以用不同的段地址和偏移地址形成同一个物理地址。
- 偏移地址16位，变化范围为0~FFFFH，仅用偏移地址来寻址最多可寻64K个内存单元。
  - 比如：给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H~1FFFFH。
- 在8086PC机中，存储单元的地址用两个元素来描述。即段地址和偏移地址。
“数据在21F60H内存单元中。”对于8086PC机的两种描述：
  1. 数据存在内存2000:1F60单元中；
  2. 数据存在内存的2000段中的1F60H单元中。
- 可根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。

## 2.9 段寄存器
- 段寄存器就是提供段地址的。
- 8086CPU有4个段寄存器：
  - CS、DS、SS、ES

## 2.10 CS和IP
- CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。
  - CS为代码段寄存器；
  - IP为指令指针寄存器。

### 8086PC读取和执行指令相关部件
```
-------------CPU--------------
　AX　　| CS 2000 → 地址
　BX　　| IP 0000 → 加法器
　　　　|　　　　　　　　↓　
　　　　|　指令缓冲器 ← 输入输出
其他部件|　　　↓　　　　控制电路
　　　　|　执行控制器　||　　||
　　　　|　　　　　　　||总线||
------------------- || -- || 
|　　　　　　|　　　|　　　　|
|20位地址总线|　　　|数据总线|
|　　　　　　|　　　|　　　　|
-------------内存-------------
B8  20000  |
23  20001  | mov ax,0123H
01  20002  |

BB  20003  |
03  20004  | mov bx,0003H
00  20005  |

89  20006  | mov ax,bx
D8  20007  |

01  20008  | add ax,bx
DB  20009  |

..  2000A
...
```

### 8086PC工作过程的简要描述
1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；
2. IP = IP + 所读取指令的长度，从而指向下一条指令；
3. 执行指令。 转到步骤 （1），重复这个过程。

在 8086CPU 加电启动或复位后（ 即 CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

### CS和IP
- 内存中指令和数据没有任何区别，都是二进制信息，CPU在工作的时候把有的信息看作指令，有的信息看作数据。
- CPU根据什么将内存中的信息看作指令？
  - CPU将CS:IP指向的内存单元中的内容看作指令。
- 在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。
- 如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过。
- 在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。
- CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。

## 2.11 修改CS、IP的指令
- 8086CPU必须提供相应的指令
- 回想我们如何修改AX中的值
  - mov 指令。如：`mov ax,123`
  - mov指令可以改变8086CPU大部分寄存器的值，被称为传送指令。
- mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的功能。
- 8086CPU为CS、IP提供了另外的指令来改变它们的值：转移指令

### 同时修改CS、IP的内容
用指令中给出的段地址修改CS，偏移地址修改IP:
```
jmp 段地址:偏移地址
jmp 2AE3:3
jmp 3:0B16
```

### 仅修改IP的内容：
用寄存器中的值修改IP:
```
jmp 某一合法寄存器
jmp ax   （类似于 mov IP,ax）
jmp bx
```

### 问题分析
内存中存放的机器码和对应汇编指令情况： （初始：CS=2000H，IP=0000H）
```
地址 内存中的机器码 对应的汇编指令

10000H  DB  |
        23  | mov ax,0123H
        01  |

10003H  B8  |
        00  | mov ax,0000
        00  |

10006H  8B  | mov bx,ax
        D8  |

10008H  FF  | jmp bx
10009H  E3  |

20000H  B8  |
        22  | mov ax,6622H
        66  |

20003H  EA  |
        03  |
        00  | jmp 1000:3
        00  |
        10  |

20008H  89  | mov cx,ax
        C1  |
```
指令执行序列：
1. mov ax,6622
2. jmp 1000:3
3. mov ax,0000
4. mov bx,ax
5. jmp bx
6. mov ax,0123H
7. 转到第（3）步执行

## 2.12 代码段
- 对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。
- 可以将长度为 `N ( N≤64KB )` 的一组代码，存在一组地址连续、起始地址为 16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。
- 例如
```
mov ax,0000  (B8 00 00)
add ax,0123  (05 23 01)
mov bx,ax    (8B D8)
jmp bx       (FF E3)
```
- 这段长度为 10 字节的字节的指令，存在从`123B0H~123B9H`的一组内存单元中，我们就可以认为，`123B0H~123B9H`这段内存单元是用来存放代码的 ，是一个代码段 ，它的段地址为123BH，长度为10字节。
- 如何使得代码段中的指令被执行呢？
  - 将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义得代码段中的指令当作指令来执行。
  - CPU 只认被 CS:IP 指向的内存单元中的内容为指令。
  - 所以要将CS:IP指向所定义的代码段中的第一条指令的首地址。
  - CS = 123BH，IP = 0000H。

### 段寄存器 CS和IP 代码段 小结
1. 段地址在8086CPU的寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址。
2. CS存放指令的段地址，IP存放指令的偏移地址。
  - 8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。
3. 8086CPU的工作过程：
  1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；
  2. IP指向下一条指令；
  3. 执行指令。（转到步骤（1），重复这个过程。）
4. 8086CPU提供转移指令修改CS、IP的内容。