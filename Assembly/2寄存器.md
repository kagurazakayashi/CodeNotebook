# 第2章 寄存器
- CPU 概述
  - 一个典型的 CPU 由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。
  - 内部总线实现 CPU 内部各个器件之间的联系。
  - 外部总线实现 CPU 和主板上其它器件的联系。
- 寄存器概述
  - 8086 CPU 有 14 个寄存器 它们的名称为：`AX`、`BX`、`CX`、`DX`、`SI`、`DI`、`SP`、`BP`、`IP`、`CS`、`SS`、`DS`、`ES`、`PSW`。

## 2.1 通用寄存器
- 8086 CPU 所有的寄存器都是 16 位的，可以存放 2 个字节。
- `AX`、`BX`、`CX`、`DX` 通常用来存放一般性数据被称为通用寄存器。
- 下面以`AX`为例，寄存器的逻辑结构:
```
               16 位寄存器的逻辑结构
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
```
- 一个16位寄存器可以存储一个16位的数据。
```
           16位数据在寄存器中的存放情况

数据：18    二进制表示：10010    在寄存器AX中的存储：
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 1| 0| 0| 1| 0|

数据：20000    二进制表示：0100111000100000
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
| 0| 1| 0| 0| 1| 1| 1| 0| 0| 0| 1| 0| 0| 0| 0| 0|
```
- 一个16位寄存器所能存储的数据的最大值为：
  - `2^16-1`

- 8086 上一代 CPU 中的寄存器都是 8 位的；
- 为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。
  - `AX` 可以分为 `AH`(高位) 和 `AL`(低位) ；
  - `BX` 可以分为 `BH`(高位) 和 `BL`(低位) ；
  - `CX` 可以分为 `CH`(高位) 和 `CL`(低位) ；
  - `DX` 可以分为 `DH`(高位) 和 `DL`(低位) 。
- 8086 CPU 的 8 位寄存器存储逻辑
- 以AX为例，8086CPU的16位寄存器分为两个8位寄存器的情况：
```
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
  7  6  5  4  3  2  1  0  7  6  5  4  3  2  1  0
[          AH          ]|[          AL          ]
```

- AX的低8位（0位~7位）构成了AL寄存器，高8位（8位~15位）构成了AH寄存器。
- AH和AL寄存器是可以独立使用的8位寄存器。
- 一个8位寄存器所能存储的数据：
  - `2^8-1`
- 8086CPU的8位寄存器数据存储情况:
```
[                      AX                       ]
 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
| 0| 1| 0| 0| 1| 1| 1| 0| 0| 0| 1| 0| 0| 0| 0| 0|
  7  6  5  4  3  2  1  0  7  6  5  4  3  2  1  0
[          AH          ]|[          AL          ]
```
| 寄存器 | 寄存器中的数据 | 所表示的值 |
| -- | ---------------: | :-----------: |
| AX | 0100111000100000 | 20000 (4E20H) |
| AH |     01001110     |    78 (4EH)   |
| AL |     00100000     |    32 (20H)   |

## 2.2 字在寄存器中的存储
一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。
```
字： (H 高位字节   L 低位字节)
0 1 0 0 1 1 1 0 0 0 1 0 0 0 0 0
[      H      ] [      L      ]
```

关于数制的讨论：
- 由于一个内存单元可以存放 8 位数据，CPU中的寄存器又可存放 n 个 8 位数据。也就是说，计算机中的数据大多是由 1~N 个 8 位数据构成的。
- 用十六进制来表示数据可以直观的看出这个数据是由哪些 8 位数据构成的。

## 2.3 几条汇编指令

**汇编指令不区分大小写**

常用汇编指令
- 汇编指令： `mov ax,18`
  - 控制CPU完成的操作： 将 8 送入 AX
  - 用高级语言语法表述： `AX = 18`
- 汇编指令： `mov ah,78`
  - 控制CPU完成的操作： 将 78 送入 AH
  - 用高级语言语法表述： `AH = 18`
- 汇编指令： `add ax,8`
  - 控制CPU完成的操作： 将寄存器 AX 中的数值加上 8
  - 用高级语言语法表述： `AX = AX + 8`
- 汇编指令： `mov ax,bx`
  - 控制CPU完成的操作： 将寄存器 BX 中的数据送入寄存器 AX
  - 用高级语言语法表述： `AX = BX`
- 汇编指令： `add ax,bx`
  - 控制CPU完成的操作： 将 AX, BX 中的内容相加，结果存在 AX 中
  - 用高级语言语法表述： `AX = AX + BX`

- CPU执行下表中的程序段的每条指令后，对寄存器中的数据进行的改变。
- `H` 是 16 进制， `B` 是 2 进制， 没有是 10 进制

- 程序段中指令执行情况之一
  - 原 AX 中的值：`0000H`，原 BX 中的值：`0000H`

| 0 | 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| - | :------------: | :-----: | :-----: |
| 1 | `mov ax,4E20H` | `4E20H` | `0000H` |
| 2 | `add ax,1406H` | `6226H` | `0000H` |
| 3 | `mov bx,2000H` | `6226H` | `2000H` |
| 4 | `add ax,bx`    | `8226H` | `2000H` |
| 5 | `mov bx,ax`    | `8226H` | `8226H` |
| 6 | `add ax,bx`    |    ?    | `8226H` |

```
求解过程
1. ax = 4E20H
2. ax = 1406H + 4E20H = 6226H
3. bx = 2000H
4. ax = ax (6226H) + bx (2000H) = 8226H
5. bx = ax (8226H)
6. ax = ax (8226H) + bx (8226H) = 1044CH
? = 044CH
```

- 程序段中指令执行情况之二
  - 原 AX 中的值：`0000H`，原 BX 中的值：`0000H`

| 0 | 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| - | :------------: | :-----: | :-----: |
| 1 | `mov ax,001AH` | `001AH` | `0000H` |
| 2 | `mov bx,0026H` | `001AH` | `0026H` |
| 3 | `add al,bl`    | `0040H` | `0026H` |
| 4 | `add ah,bl`    | `2640H` | `0026H` |
| 5 | `add bh,al`    | `2640H` | `4026H` |
| 6 | `mov ah,0`     | `0040H` | `4026H` |
| 7 | `add al,85H`   | `00C5H` | `4026H` |
| 8 | `add al,93H`   |    ?    | `4026H` |

```
AX = 00C5, AH = 00, AL = C5
求解过程
1. ax = 001AH
2. bx = 0026H
3. al = al (1AH) + bl (26H) = 40H, AX = 0040H
4. ah = ah (00H) + bl (26H) = 26H, AX = 2640H
5. bh = bh (00H) + al (40H) = 40H, BX = 4026H
6. ah = 00 40 H
7. al = al (40H) + 85H = C5H, AX = 00C5H
8. al = al (C5H) + 93H = 158H -> 58H, AX = 0058H
```

- 这里的丢失，指的是进位制不能在 8 位寄存器中保存，但是 CPU 不是并真的不丢弃 这个进位值，这个问题会在后面的课程中讨论。

## 2.4 物理地址
- CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。
- 每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地址。

## 2.5 16位结构的CPU
概括的讲，16位结构描述了一个CPU具有以下几个方面特征：
1. 运算器一次最多可以处理16位的数据。
2. 寄存器的最大宽度为16位。
3. 寄存器和运算器之间的通路是16位的。

## 2.6 8086CPU给出物理地址的方法
- 8086有20位地址总线，可传送20位地址，寻址能力为1M。
- 8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K。
- 8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。
- 地址加法器合成物理地址的方法： `物理地址 = 段地址 × 16 + 偏移地址`
  - 例如：8086CPU访问地址为123C8H的内存单元
    - 123 x 16 = 1230 + 00C8
- 由段地址×16引发的讨论:

| 移位位数 | 二进制 | 十六进制 | 十进制 |
| --- | ---------: | ----: | ---: |
| `0` | `    10 B` | ` 2H` | ` 2` |
| `1` | `   100 B` | ` 4H` | ` 4` |
| `2` | `  1000 B` | ` 8H` | ` 8` |
| `3` | ` 10000 B` | `10H` | `16` |
| `4` | `100000 B` | `20H` | `32` |

观察移位次数和各种形式数据的关系：
1. 一个数据的二进制形式左移1位，相当于该数据乘以2；
2. 一个数据的二进制形式左移N位，相当于该数据乘以2的N次方；
3. 地址加法器如何完成段地址×16的运算？**以二进制形式存放的段地址左移4位。**

## 2.7 `段地址 × 16 + 偏移地址 = 物理地址` 的本质含义
两个比喻说明：
- 说明 `基础地址 + 偏移地址 = 物理地址` 的思想：第一个比喻
- 说明 `段地址 × 16 + 偏移地址 = 物理地址` 的思想：第二个比喻
  - 8086CPU就是这样一个只能提供两张3位数据纸条的CPU。

### `基础地址 + 偏移地址 = 物理地址`
```
学校                 体育馆         图书馆
 |_____________________|_____________|
0 m                  2000 m        2826 m
```
- 比如说，学校、体育馆同在一条笔直的单行路上（学校位于路的起点`0m`处）。
- 读者在学校，要去图书馆，问我那里的地址，我可以用几种方式描述这个地址？
  1. 从学校走`2826m`到图书馆。这`2826`可以认为是图书馆的物理地址。
  2. 从学校走`2000m`到体育馆，从体育馆再走`826m`到图书馆。
    - 第一个距离`2000m`是相对于起点的基础地址；
    - 第二个距离`826m`是将对于基础地址的偏移地址。

### `段地址 × 16 + 偏移地址 = 物理地址`
- 比如我们只能通过纸条来通信，读者问我图书馆的地址，我只能将它写在纸上告诉读者。
- 显然我必须有一张可以容纳 `4` 位数据的纸条才能写下 `2826` 这个数据：
  - `| 2 | 8 | 2 | 6 |`
- 不巧的是，没有能容纳4位数据的纸条，仅有两张可以容纳3位数据的纸条。
  - 这样我只能以这种方式告诉读者2826这个数据：
    - `| 2 | 0 | 0 |`
    - `| 8 | 2 | 6 |`

## 2.8 段的概念
- 错误认识：
  - 内存被划分成了一个一个的段，每一个段有一个段地址。
- 其实：
  - 内存并没有分段，段的划分来自于CPU，由于8086CPU用 `(段地址 × 16) + 偏移地址 = 物理地址` 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

```
[        ]
[ 10000H ] ---------------
[        ]
[        ] 10000H ~ 100FFH
[  ....  ] 单元组成一个段
[        ]
[        ]
[ 100FFH ] ---------------
[        ]
```
- 我们可以认为：地址`10000H ~ 100FFH`的内存单元组成一个段，该段的起始地址（ 基础地址）为`10000H`，段地址为`1000H`，大小为`100H`。

```
[        ]
[ 10000H ] ---------------
[        ] 10000H ~ 1007FH
[        ] 单元组成一个段
[ 1007FH ] ---------------
[ 10080H ] ---------------
[        ] 10080H ~ 100FFH
[        ] 单元组成一个段
[ 100FFH ] ---------------
[        ]
```
- 我们也可以认为地址`10000H~1007FH`、`10080H~100FFH`的内存单元组成两个段，它们的起始地址（ 基础地址 ）为`10000H`和`10080H`，段地址为：`1000H`和`1008H`，大小都为`80H`。

--------------- TODO