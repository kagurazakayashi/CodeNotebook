# 第3章 寄存器（内存访问）
- 在第2章中，我们主要从 CPU 如何执行指令的角度讲解了8086CPU的逻辑结构、形成物理地址的方法、相关的寄存器以及一些指令。
- 这一章中，我们从访问内存的角度继续学习几个寄存器。

## 3.1 内存中字的存储
在 0 地址处开始存放 20000 (4E20H):
```
内存中字的存储：
0 |  20H  | 低地址单元
1 |  4EH  | 高地址单元
2 |  12H  |
3 |  00H  |
4 |       |
5 |       |
```
1. 0 地址单元中存放的 字节型 数据是多少？ `20H`
2. 0 地址单元中存放的 　字型 数据是多少？ `4E20H` （一个字需要2个字节）
3. 2 地址单元中存放的 字节型 数据是多少？ `12H`
4. 2 地址单元中存放的 　字型 数据是多少？ `0012H`
5. 1 地址单元中存放的 　字型 数据是多少？ `124EH`
结论：
- 任何两个地址连续的内存单元，N号单元和 N+1号单元，可以将它们看成两个内存单元 ，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元。

## 3.2 DS和[address]
- CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；
- 在8086PC中，内存地址由段地址和偏移地址组成。
- 8086CPU中有一个 DS寄存器，通常用来存放要访问的数据的段地址。
- 例如我们要读取`10000H`单元的内容可以用如下程序段进行：
```
mov bx,1000H
mov ds,bx
mov al,[0]
```
- 上面三条指令将`10000H (1000:0)`中的数据读到 al 中。
- `mov al,[0]` :
  - 已知的mov指令可完成的两种传送功能：
    1. 将数据直接送入寄存器；
    2. 将一个寄存器中的内容送入另一个寄存器中。
  - mov 指令 还可以将一个内存单元中的内容送入一个寄存器。
  - 从哪个内存单元送到哪个寄存器中呢？
  - mov指令的格式： `mov 寄存器名,内存单元地址`
  - `[…]`表示一个内存单元， `[…]`中的`0`表示内存单元的偏移地址。

- 执行指令时，8086CPU自动取DS中的数据为内存单元的段地址。
- 如何用mov指令从10000H中读取数据？
  - `10000H`表示为`1000:0`（段地址:偏移地址）
  - 将段地址`1000H`放入`ds`
  - 用`mov al,[0]`完成传送（mov指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0，它的段地址默认放在ds中）
- 如何把1000H送入ds？
  - 传送指令 mov ax,1
  - 相似的方式 mov ds,1000H?
  - 8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器。（硬件设计的问题）
  - mov ds,1000H 是非法的。
  - 数据 → 一般的寄存器 → 段寄存器

- 问题：写几条指令，将al中的数据送入内存单元10000H？（思考后分析）
- 分析：怎样将数据从寄存器送入内存单元？
- 结论：
```
mov bx,1000H
mov ds,bx
mov [0],al
```

## 3.3 字的传送
因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是一次性传送一个字。
```
mov bx,1000H
mov ds,bx
mov ax,[0]   ; 1000:0 处的字型数据传入 ax
mov [0],cx   ; cx 中的 16 位数据送到 1000:0 处
```

### 问题：内存中的情况如下，写出下面指令执行后寄存器ax，bx，cx中的值。
```
指令：　　　　　　内存状况示意：
mov ax,1000H    10000H : 23
mov ds,ax       10001H : 11
mov ax,[0]      10002H : 22
mov bx,[2]      10003H : 66
mov cx,[1]
add bx,[1]
add cx,[2]
```
| 指令 | 执行后相关寄存器中的内容 | 说明 |
| -------------- | ------------ | - |
| `mov ax,1000H` | `ax = 1000H` |   |
| `mov ds,ax`    | `ds = 1000H` | 前两条指令的目的是将ds设为1000H |
| `mov ax,[0]`   | `ax = 1123H` | 1000:0处存放的字型数据送入ax； |
|                |              | 1000:1单元处存放的字型数据的高8位:11H； |
|                |              | 1000:0单元处存放的字型数据的低8位:23H； |
|                |              | 所以1000:0处存放的字型数据为1123H。 |
|                |              | 指令执行时，字型数据的高8位送入ah，字型数 |
|                |              | 据的低8位送入al，则ax中的数据为1123H |
| `mov bx,[2]`   | `bx = 6622H` | 以下原理同上 |
| `mov cx,[1]`   | `cx = 2211H` |   |
| `add bx,[1]`   | `bx = 8833H` |   |
| `add cx,[2]`   | `cx = 8833H` |   |

### 问题：内存中的情况如下，写出下面指令执行后寄存器ax，bx，cx中的值。
```
指令：　　　　　　内存状况示意：
mov ax,1000H    10000H : 23
mov ds,ax       10001H : 11
mov ax,11316    10002H : 22
mov [0],ax      10003H : 11
mov bx,[0]
sub bx,[2]
mov [2],bx
```
| 指令 | 执行后相关寄存器或内存单元中的内容 | 说明 |
| -------------- | ------------- | - |
| `mov ax,1000H` | `ax = 1000H`  |   |
| `mov ds,ax`    | `ds = 1000H`  | 前两条指令的目的是将ds设为1000H |
|                |               |   |
| `mov ax,11316` | `ax = 2C34H`  | 十进制11316，十六进制2C34H |
| `mov [0],ax`   | `10000H : 34` | ax中的字型数据送到1000:0处： |
|                | `10001H : 2C` | ax中的字型数据是2C34H， |
|                | `10002H : 22` | 高8位：2CH，在ah中， |
|                | `10003H : 11` | 低8位：34H，在al中， |
|                |               | 指令执行时，高8位送入高地址1000:1单 |
|                |               | 元，低8位送入低地址1000:0单元 |
|                |               |   |
| `mov bx,[0]`   | `bx = 2C34H`  |   |
| `sub bx,[2]`   | `bx = 1B12H`  | bx = bx中的字型数据 - 1000:2 处的字型数 |
|                |               | 据 = 2C34H - 1122H = 1B12H |
|                |               |   |
| `mov [2],bx`   | `10000H : 34` | bx中的字型数据送到1000:2处 |
| `mov [2],bx`   | `10001H : 2C` |   |
| `mov [2],bx`   | `10002H : 12` |   |
| `mov [2],bx`   | `10003H : 1B` |   |

## 3.4 mov、add、sub指令
已学`mov`指令的几种形式：
- `mov 寄存器　，数据　　`　　`mov ax,1000H`
- `mov 寄存器　，寄存器　`　　`mov ax,bx`
- `mov 寄存器　，内存单元`　　`mov ax,[0]`
- `mov 内存单元，寄存器　`　　`mov [0],ax`
- `mov 段寄存器，寄存器　`　　`mov ds,ax`

`add`和`sub`指令同`mov`一样，都有两个操作对象。
- `add 寄存器　，数据　　`　　比如: `add ax,8`
- `add 寄存器　，寄存器　`　　比如: `add ax,bx`
- `add 寄存器　，内存单元`　　比如: `add ax,[0]`
- `add 内存单元，寄存器　`　　比如: `add [0],ax`
- `sub 寄存器　，数据　　`　　比如: `sub x,9`
- `sub 寄存器　，寄存器　`　　比如: `sub ax,bx`
- `sub 寄存器　，内存单元`　　比如: `sub ax,[0]`
- `sub 内存单元，寄存器　`　　比如: `sub [0],ax`

## 3.5 数据段
- 前面讲过，对于8086PC机，我们可以根据需要将一组内存单元定义为一个段。
- 我们可以将一组长度为`N (N≤64K)`、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。
- 比如我们用`123B0H~123B9H`这段空间来存放数据：
  - 段地址：123BH
  - 长度：10字节
- 如何访问数据段中的数据呢？
  - 将一段内存当作数据段，是我们在编程时的一种安排，我们可以在具体操作的时候 ，用 ds 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。
- 我们将`123B0H~123BAH`的内存单元定义为数据段，我们现在要累加这个数据段中的前3个单元中的数据，代码如下：
```
mov ax,123BH
mov ds,ax    ;将123BH送入ds中，作为数据段的段地址
mov al,0     ;用al存放累加结果
add al,[0]   ;将数据段第一个单元（偏移地址为0）中的数值加到al中
add al,[1]   ;将数据段第二个单元（偏移地址为1）中的数值加到al中
add al,[2]   ;将数据段第三个单元（偏移地址为2）中的数值加到al中
```

问题：写几条指令，累加数据段中的前3个字型数据。
```
mov ax,123BH
mov ds,ax    ;将123BH送入ds中，作为数据段的段地址
mov al,0     ;用al存放累加结果
add ax,[0]   ;将数据段第一个单元（偏移地址为0）中的数值加到ax中
add ax,[2]   ;将数据段第二个单元（偏移地址为2）中的数值加到ax中
add ax,[4]   ;将数据段第三个单元（偏移地址为4）中的数值加到ax中
```
注意：一个字型数据占两个单元，所以偏移地址是0、2、4。

## 以上 3.1节~3.5节 小结
1. 字在内存中存储时 ，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。
2. 用 mov 指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。
3. [address]表示一个偏移地址为address的内存单元。
4. 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。
5. mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。