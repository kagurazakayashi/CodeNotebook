# 第3章 寄存器（内存访问）
- 在第2章中，我们主要从 CPU 如何执行指令的角度讲解了8086CPU的逻辑结构、形成物理地址的方法、相关的寄存器以及一些指令。
- 这一章中，我们从访问内存的角度继续学习几个寄存器。

## 3.1 内存中字的存储
在 0 地址处开始存放 20000 (4E20H):
```
内存中字的存储：
0 |  20H  | 低地址单元
1 |  4EH  | 高地址单元
2 |  12H  |
3 |  00H  |
4 |       |
5 |       |
```
1. 0 地址单元中存放的 字节型 数据是多少？ `20H`
2. 0 地址单元中存放的 　字型 数据是多少？ `4E20H` （一个字需要2个字节）
3. 2 地址单元中存放的 字节型 数据是多少？ `12H`
4. 2 地址单元中存放的 　字型 数据是多少？ `0012H`
5. 1 地址单元中存放的 　字型 数据是多少？ `124EH`
结论：
- 任何两个地址连续的内存单元，N号单元和 N+1号单元，可以将它们看成两个内存单元 ，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元。

## 3.2 DS和[address]
- CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；
- 在8086PC中，内存地址由段地址和偏移地址组成。
- 8086CPU中有一个 DS寄存器，通常用来存放要访问的数据的段地址。
- 例如我们要读取`10000H`单元的内容可以用如下程序段进行：
```
mov bx,1000H
mov ds,bx
mov al,[0]
```
- 上面三条指令将`10000H (1000:0)`中的数据读到 al 中。
- `mov al,[0]` :
    - 已知的mov指令可完成的两种传送功能：
        1. 将数据直接送入寄存器；
        2. 将一个寄存器中的内容送入另一个寄存器中。
    - mov 指令 还可以将一个内存单元中的内容送入一个寄存器。
    - 从哪个内存单元送到哪个寄存器中呢？
    - mov指令的格式： `mov 寄存器名,内存单元地址`
    - `[…]`表示一个内存单元， `[…]`中的`0`表示内存单元的偏移地址。

- 执行指令时，8086CPU自动取DS中的数据为内存单元的段地址。
- 如何用mov指令从10000H中读取数据？
    - `10000H`表示为`1000:0`（段地址:偏移地址）
    - 将段地址`1000H`放入`ds`
    - 用`mov al,[0]`完成传送（mov指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0，它的段地址默认放在ds中）
- 如何把1000H送入ds？
    - 传送指令 mov ax,1
    - 相似的方式 mov ds,1000H?
    - 8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器。（硬件设计的问题）
    - mov ds,1000H 是非法的。
    - 数据 → 一般的寄存器 → 段寄存器

- 问题：写几条指令，将al中的数据送入内存单元10000H？（思考后分析）
- 分析：怎样将数据从寄存器送入内存单元？
- 结论：
```
mov bx,1000H
mov ds,bx
mov [0],al
```

## 3.3 字的传送
因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是一次性传送一个字。
```
mov bx,1000H
mov ds,bx
mov ax,[0]   ; 1000:0 处的字型数据传入 ax
mov [0],cx   ; cx 中的 16 位数据送到 1000:0 处
```

### 问题：内存中的情况如下，写出下面指令执行后寄存器ax，bx，cx中的值。
```
指令：　　　　　　内存状况示意：
mov ax,1000H    10000H : 23
mov ds,ax       10001H : 11
mov ax,[0]      10002H : 22
mov bx,[2]      10003H : 66
mov cx,[1]
add bx,[1]
add cx,[2]
```
| 指令 | 执行后相关寄存器中的内容 | 说明 |
| -------------- | ------------ | - |
| `mov ax,1000H` | `ax = 1000H` |   |
| `mov ds,ax`    | `ds = 1000H` | 前两条指令的目的是将ds设为1000H |
| `mov ax,[0]`   | `ax = 1123H` | 1000:0处存放的字型数据送入ax； |
|                |              | 1000:1单元处存放的字型数据的高8位:11H； |
|                |              | 1000:0单元处存放的字型数据的低8位:23H； |
|                |              | 所以1000:0处存放的字型数据为1123H。 |
|                |              | 指令执行时，字型数据的高8位送入ah，字型数 |
|                |              | 据的低8位送入al，则ax中的数据为1123H |
| `mov bx,[2]`   | `bx = 6622H` | 以下原理同上 |
| `mov cx,[1]`   | `cx = 2211H` |   |
| `add bx,[1]`   | `bx = 8833H` |   |
| `add cx,[2]`   | `cx = 8833H` |   |

### 问题：内存中的情况如下，写出下面指令执行后寄存器ax，bx，cx中的值。
```
指令：　　　　　　内存状况示意：
mov ax,1000H    10000H : 23
mov ds,ax       10001H : 11
mov ax,11316    10002H : 22
mov [0],ax      10003H : 11
mov bx,[0]
sub bx,[2]
mov [2],bx
```
| 指令 | 执行后相关寄存器或内存单元中的内容 | 说明 |
| -------------- | ------------- | - |
| `mov ax,1000H` | `ax = 1000H`  |   |
| `mov ds,ax`    | `ds = 1000H`  | 前两条指令的目的是将ds设为1000H |
|                |               |   |
| `mov ax,11316` | `ax = 2C34H`  | 十进制11316，十六进制2C34H |
| `mov [0],ax`   | `10000H : 34` | ax中的字型数据送到1000:0处： |
|                | `10001H : 2C` | ax中的字型数据是2C34H， |
|                | `10002H : 22` | 高8位：2CH，在ah中， |
|                | `10003H : 11` | 低8位：34H，在al中， |
|                |               | 指令执行时，高8位送入高地址1000:1单 |
|                |               | 元，低8位送入低地址1000:0单元 |
|                |               |   |
| `mov bx,[0]`   | `bx = 2C34H`  |   |
| `sub bx,[2]`   | `bx = 1B12H`  | bx = bx中的字型数据 - 1000:2 处的字型数 |
|                |               | 据 = 2C34H - 1122H = 1B12H |
|                |               |   |
| `mov [2],bx`   | `10000H : 34` | bx中的字型数据送到1000:2处 |
| `mov [2],bx`   | `10001H : 2C` |   |
| `mov [2],bx`   | `10002H : 12` |   |
| `mov [2],bx`   | `10003H : 1B` |   |

## 3.4 mov、add、sub指令
已学`mov`指令的几种形式：
- `mov 寄存器　，数据　　`　　`mov ax,1000H`
- `mov 寄存器　，寄存器　`　　`mov ax,bx`
- `mov 寄存器　，内存单元`　　`mov ax,[0]`
- `mov 内存单元，寄存器　`　　`mov [0],ax`
- `mov 段寄存器，寄存器　`　　`mov ds,ax`

`add`和`sub`指令同`mov`一样，都有两个操作对象。
- `add 寄存器　，数据　　`　　比如: `add ax,8`
- `add 寄存器　，寄存器　`　　比如: `add ax,bx`
- `add 寄存器　，内存单元`　　比如: `add ax,[0]`
- `add 内存单元，寄存器　`　　比如: `add [0],ax`
- `sub 寄存器　，数据　　`　　比如: `sub x,9`
- `sub 寄存器　，寄存器　`　　比如: `sub ax,bx`
- `sub 寄存器　，内存单元`　　比如: `sub ax,[0]`
- `sub 内存单元，寄存器　`　　比如: `sub [0],ax`

## 3.5 数据段
- 前面讲过，对于8086PC机，我们可以根据需要将一组内存单元定义为一个段。
- 我们可以将一组长度为`N (N≤64K)`、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。
- 比如我们用`123B0H~123B9H`这段空间来存放数据：
    - 段地址：123BH
    - 长度：10字节
- 如何访问数据段中的数据呢？
    - 将一段内存当作数据段，是我们在编程时的一种安排，我们可以在具体操作的时候 ，用 ds 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。
- 我们将`123B0H~123BAH`的内存单元定义为数据段，我们现在要累加这个数据段中的前3个单元中的数据，代码如下：
```
mov ax,123BH
mov ds,ax    ;将123BH送入ds中，作为数据段的段地址
mov al,0     ;用al存放累加结果
add al,[0]   ;将数据段第一个单元（偏移地址为0）中的数值加到al中
add al,[1]   ;将数据段第二个单元（偏移地址为1）中的数值加到al中
add al,[2]   ;将数据段第三个单元（偏移地址为2）中的数值加到al中
```

问题：写几条指令，累加数据段中的前3个字型数据。
```
mov ax,123BH
mov ds,ax    ;将123BH送入ds中，作为数据段的段地址
mov al,0     ;用al存放累加结果
add ax,[0]   ;将数据段第一个单元（偏移地址为0）中的数值加到ax中
add ax,[2]   ;将数据段第二个单元（偏移地址为2）中的数值加到ax中
add ax,[4]   ;将数据段第三个单元（偏移地址为4）中的数值加到ax中
```
注意：一个字型数据占两个单元，所以偏移地址是0、2、4。

## 以上 3.1节~3.5节 小结
1. 字在内存中存储时 ，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。
2. 用 mov 指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。
3. [address]表示一个偏移地址为address的内存单元。
4. 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。
5. mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。

## 3.6 栈
- 我们研究栈的角度：
    - 栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。
    - 后进先出

- 入栈的方式：
```
|   |    |   |    |   |    |   |
|   |    |   |    |   |    | C |
|   | A  |   |    | B |    | B |
|   | B  | A | B  | A |    | A |
|___| C  |___| C  |___| C  |___|
```
- 出栈的方式：
```
|   |    |   |    |   |    |   |
| C |    |   |    |   |    |   |
| B |    | B |    |   |    |   | A
| A |    | A |    | A | B  |   | B
|___|    |___| C  |___| C  |___| C
```

- 栈有两个基本的操作：入栈和出栈。
    - 入栈：将一个新的元素放到栈顶；
    - 出栈：从栈顶取出一个元素。
- 栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。
- 栈的操作规则：LIFO
	- （Last In First Out，后进先出）

## 3.7 CPU提供的栈机制
- 8086CPU提供入栈和出栈指令：（最基本的）
    - PUSH（入栈）
        - `push ax` ：将寄存器ax中的数据送入栈中；
    - POP （出栈）
        -  `pop ax` ：从栈顶取出数据送入ax。
- 8086CPU的入栈和出栈操作都是以字为单位进行的。

## 3.6 栈举例
- 下面举例说明，我们可以将`10000H`~`1000FH`这段内存当作栈来使用。
- 注意：字型数据用两个单元存放，高地址单元放高 8 位，低地址单元放低 8 位。
- 下面一段指令的执行过程：
```
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
```

1. CPU如何知道一段内存空间被当作栈使用？
2. 执行push和pop的时候，如何知道哪个单元是栈顶单元？
- 任意时刻，SS:SP指向栈顶元素
    - SS：段寄存器
    - SP：寄存器

### push 指令的执行过程
- push ax
    1. SP=SP–2；
    2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

#### push 指令的执行过程 1
当前的状态：
- SS中的内容：`1000H`
- SP中的内容：`000EH`
    - 则栈顶的段地址为 `1000:000E`，即 `1000EH`
- ax中的内容：`2266H`

```
10000H |    | SS=1000H
   .   |    | SP=000EH
   .   |    |
   .   |    | AX=2266H
1000BH |    |
1000CH |    |
1000DH |    |
1000EH | 23 | <- SS:SP
1000FH | 01 |
```

#### push 指令的执行过程 2
CPU执行 `push ax`
- 第一步：`SP=SP-2`
    - SP中的内容变为：`000CH`
    - SS:SP指向 `1000:000C`
    - 栈顶的地址变为 `1000:000C` 即 `1000CH`

```
10000H |    | SS=1000H
   .   |    | SP=000CH
   .   |    |
   .   |    | AX=2266H
1000BH |    |
1000CH |    | <- SS:SP
1000DH |    |
1000EH | 23 |
1000FH | 01 |
```

#### push 指令的执行过程 3
CPU执行 `push ax`
- 第二步：
    - 将 ax 中的数据送入 `SS:SP` 指向的内存单元处。

```
10000H |    | SS=1000H
   .   |    | SP=000CH
   .   |    |
   .   |    | AX=2266H
1000BH |    |
1000CH | 66 | <- SS:SP
1000DH | 22 |
1000EH | 23 |
1000FH | 01 |
```

#### push 指令问题
如果我们将 `10000H~1000FH` 这段空间当作栈，初始状态栈是空的，此时，`SS=1000H`，`SP=?`
- `SP = 0010H` ， 过程：

#### push 指令问题过程 1
栈空，`SS:SP`指向占空间最高地址单元的下一个单元。

```
+栈空间
+ 10000H |    | SS=1000H
+    .   |    | SP=0010H
+    .   |    | AX=2266H
+ 1000DH |    |
+ 1000EH |    |
+ 1000FH |    |
  10010H |    | <- SS:SP
```

#### push 指令问题过程 2
执行 `push ax` 后，`SS:SP`指向栈中的第一个元素。

```
+栈空间
+ 10000H |    | SS=1000H
+    .   |    | SP=0010H
+    .   |    | AX=2266H
+ 1000DH |    |
+ 1000EH | 66 | <- SS:SP
+ 1000FH | 22 |
  10010H |    |
```

#### push 指令问题过程
- 我们将 `10000H~1000FH` 这段空间当作栈段，`SS=1000H`，栈空间大小为 16 字节 ，栈最底部的字单元地址为`1000:000E`。
    - 任意时刻，`SS:SP` 指向栈顶，当栈中只有一个元素的时候，`SS = 1000H`，`SP=000EH`。　
- 栈为空，就相当于栈中唯一的元素出栈，出栈后，`SP=SP+2` ，SP 原来为 `000EH`，加 2 后`SP=10H`，所以，当栈为空的时候，`SS=1000H`，`SP=10H`。
- 换个角度看：
    - 任意时刻，`SS:SP` 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以 `SS:SP` 只能指向栈的最底部单元下面的单元，该单元的偏移地址为`栈最底部的字单元的偏移地址+2`，栈最底部字单元的地址为`1000:000E`，所以栈空时，`SP=0010H`。

### pop 指令的执行过程
- pop ax
    1. 将SS:SP指向的内存单元处的数据送入ax中；
    2. SP = SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

#### pop 指令的执行过程 1
初始状态

```
10000H |    | SS=1000H
   .   |    | SP=000CH
   .   |    |
1000BH |    |
1000CH | 66 | <- SS:SP
1000DH | 22 |
1000EH | 23 |
1000FH | 01 |
```

#### pop 指令的执行过程 2
CPU 执行 `pop ax`
- 第一步：将`SS:SP`指向的内存单元处的数据送入`ax`中，即`ax=2266H`

```
10000H |    | SS=1000H
   .   |    | SP=000EH
   .   |    |
1000BH |    |
1000CH | 66 |
1000DH | 22 |
1000EH | 23 | <- SS:SP
1000FH | 01 |
```

#### pop 指令的执行过程 3
CPU 执行 `pop ax`
- 第二步：
    - `SP=SP+2`
    - `SS:SP`指向`1000EH`

#### pop 指令的执行过程 注意：
- 出栈后，`SS:SP`指向新的栈顶 `1000EH`，pop操作前的栈顶元素，`1000CH` 处的 `2266H` 依然存在，但是，它已不在栈中。
- 当再次执行`push`等入栈指令后，`SS:SP`移至`1000CH`，并在里面写入新的数据，它将被覆盖。

## 3.8 栈顶超界的问题
- `SS`和`SP`只记录了栈顶的地址，依靠`SS`和`SP`可以保证在入栈和出栈时找到栈顶。
- 可是，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？
- 当**栈满的时候再使用push指令入栈**，**栈空的时候再使用pop指令出栈**，都将发生栈顶超界问题。
- 栈顶超界是危险的。
    - 因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己的程序中的，也可能是别的程序中的。（毕竟一个计算机系统并不是只有我们自己的程序在运行）
- 但是由于我们在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。
- 我们当然希望CPU可以帮我们解决这个问题
    - 比如说在CPU中有记录栈顶上限和下限的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围 ，然后 ，CPU 在执行push指令的时候靠检测栈顶上限寄存器，在执行pop指令的时候靠检测栈顶下限寄存器保证不会超界。
    - 实际情况：8086CPU中并没有这样的寄存器。8086CPU不保证对栈的操作不会超界。
        - 这就是说， 8086CPU 只知道栈顶在何处（由`SS:SP`指示），而不知道读者安排的栈空间有多大。
        - 这点就好像，CPU 只知道当前要执行的指令在何处（由`CS:SP`指示）而不知道读者要执行的指令有多少。
    - 8086CPU的工作机理，只考虑当前的情况：
        - 当前栈顶在何处；
        - 当前要执行的指令是哪一条。
- 我们在编程的时候要自己操心栈顶超界的问题
    - 要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；
    - 执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。
- 栈与内存
    - 栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。

## push、pop 指令
- `push`和`pop`指令是可以在寄存器和内存之间传送数据的。
  - 栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。
- `push`和`pop`指令的格式 (1)
    - `push` 寄存器：将一个寄存器中的数据入栈
    -  `pop` 寄存器：出栈，用一个寄存器接收出栈的数据
    - 例如：
        - `push ax`
        - `pop bx`
- `push`和`pop`指令的格式 (2)
    - `push` 段寄存器：将一个段寄存器中的数据入栈
    -  `pop` 段寄存器：出栈，用一个段寄存器接收出栈的数据
    - 例如：
        - `push ds`
        - `pop es`
- `push`和`pop`指令的格式 (3)
    - `push` 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）
    -  `pop` 内存单元：出栈，用一个内存字单元接收出栈的数据
    - 例如：
        - `push [0]`
        - `pop [2]`
    - 指令执行时 ，CPU 要知道内存单元的地址，可以在 push、pop 指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中取得。

### push、pop 指令问题 3.7
编程：将 `10000H~1000FH` 这段空间当作栈，初始状态是空的，将 `AX`、`BX`、`DS`中的数据入栈。
```
mov ax,1000H
mov ss,ax     ;设置栈的段地址，SS=1000H，不能直接向段寄存器
              ;SS送入数据，所以用ax中转。
mov sp,0010H  ;设置栈顶的偏移地址，因为栈为空，所以SP=0010H。
              ;如果对栈为空时SP的设置还有疑问参考3.7中的问题。
;上面三条指令设置栈顶地址。编程中要自己注意栈的大小。
push ax
push bx
push ds
```

### push、pop 指令问题 3.8
编程：
1. 将 `10000H~1000FH` 这段空间当作栈，初始状态是空的；
2. 设置`AX=001AH`，`BX=001BH`；
3. 将`AX`、`BX`中的数据入栈；
4. 然后将`AX`、`BX`清零；
5. 从栈中恢复`AX`、`BX`原来的内容。
```
mov ax,1000H
mov ss,ax
mov sp,0010H  ;初始化栈顶，栈的情况如图A所示
mov ax,001AH
mov bx,001BH
push ax
push bx       ;ax、bx入栈，栈的情况如图B所示
sub ax,ax     ;将ax清零，也可以用mov ax,0，
              ;sub ax,ax的机器码为2个字节，
              ;mov ax,0 的机器码为3个字节。
sub bx,bx
pop bx        ;从栈中恢复ax、bx原来的数据，
pop ax        ;当前栈顶的内容是bx中原来的内容：001BH，
              ;ax中原来的内容 001AH 在栈顶的下面，
              ;所以要先 pop bx，然后再 pop ax。
```
#### 图A: 栈初始化的情况
```
1000CH |    |
1000DH |    |
1000EH |    |
1000FH |    |
10010H |    | <- SS:SP
```
#### 图B: ax、bx 入栈的情况
```
1000CH | 1B | \ <- SS:SP
1000DH | 00 | / bx 中的值
1000EH | 1A | \
1000FH | 00 | / ax 中的值
10010H |    |
```
#### 结论
- 从上面的程序我们看到，用栈来暂存以后需要恢复的寄存器中的内容时 ，出栈的顺序要和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。

### push、pop 指令问题 3.9
编程：
1. 将 `10000H~1000FH` 这段空间当作栈，初始状态是空的；
2. 设置`AX=002AH`，`BX=002BH`；
3. 利用栈 ，交换 `AX` 和 `BX` 中的数据。
```
mov ax,1000H
mov ss,ax
mov sp,0010H  ;初始化栈顶，栈的情况如图A所示
mov ax,002AH
mov bx,002BH
push ax
push bx       ;ax、bx入栈，栈的情况如图B所示
pop ax        ;当前栈顶的数据是bx中原来的数据：002B
              ;所以先pop ax，ax=002BH
pop bx        ;执行pop ax后，栈顶的数据为ax原来的数据
              ;所以再pop bx，bx=002AH
```
#### 图A: 栈初始化的情况
```
1000CH |    |
1000DH |    |
1000EH |    |
1000FH |    |
10010H |    | <- SS:SP
```
#### 图B: ax、bx 入栈的情况
```
1000CH | 2B | \ <- SS:SP
1000DH | 00 | / bx 中的值
1000EH | 2A | \
1000FH | 00 | / ax 中的值
10010H |    |
```

### push、pop 指令问题 3.10
我们如果要在10000H处写入字型数据2266H，可以用以下的代码完成：
```
mov ax,1000H
mov ds,ax
mov ,ax,2266H
mov [0],ax
```
补全下面的代码，完成同样的功能：在10000H处写入字型数据2266H。
```
__________
__________
__________
mov ax,2266H
push ax
```
要求：不能使用`mov 内存单元,寄存器`这类指令。

#### 分析
- 我们看需补全代码的最后两条指令，将`ax`中的`2266H`压入栈中，也就是说，最终应由`push ax`将`2266H`写入`10000H`处。
- 问题的关键就在于：如何使`push ax`访问的内存单元是`10000H`。
- `push`指令是入栈指令。（注意执行过程）
- 完成的程序：
```
mov ax,1000H
mov ss,ax
mov sp,2
mov ax,2266H
push ax
```
- 结论
    - `push`、`pop` 实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与`mov`指令不同的是，`push`和`pop`指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。
    - 同时，`push`和`pop`指令还要改变 `SP` 中的内容。
- 我们要十分清楚的是，push和pop指令同mov指令不同，CPU执行mov指令只需一步操作，就是传送，而执行push、pop指令却需要两步操作。
- 执行push时：
    - 先改变SP，后向SS:SP处传送。
- 执行pop时：
    - 先读取SS:SP处的数据，后改变SP。

### 注意
- `push`、`pop` 等栈操作指令，修改的只是`SP`。
    - 也就是说，栈顶的变化范围最大为：`0~FFFFH`。
- 提供：
    - `SS`、`SP`指示栈顶；
    - 改变`SP`后写内存的入栈指令；
    - 读内存后改变`SP`的出栈指令。
- 这就是8086CPU提供的栈操作机制。

### 栈的综述
1. 8086CPU提供了栈操作机制，方案如下：
    - 在`SS`，`SP`中存放栈顶的段地址和偏移地址；
    - 提供入栈和出栈指令，他们根据`SS:SP`指示的地址，按照栈的方式访问内存单元。
2. push指令的执行步骤：
    1. `SP=SP-2`；
    2. 向`SS:SP`指向的字单元中送入数据。
3. pop指令的执行步骤：
    1. 从`SS:SP`指向的字单元中读取数据；
    2. `SP=SP-2`。
4. 任意时刻，SS:SP指向栈顶元素。
5. 8086CPU只记录栈顶，栈空间的大小我们要自己管理。
6. 用栈来暂存以后需要恢复的寄存器的内容时 ，寄存器出栈的顺序要和 入栈的顺序相反。
7. push、pop实质上是一种内存传送指令，注意它们的灵活应用。

栈是一种非常重要的机制，一定要深入理解，灵活掌握。

## 3.10 栈段
- 对于8086PC机，在编程时，我们可以根据需要，将一组内存单元定义为一个段。
- 我们可以将长度为 `N ( N ≤ 64K )` 的一组地址连续、起始地址为16的倍数的内存单元，当作栈来用，从而定义了一个栈段。
  - 将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就在执行`push`、`pop`等站操作指令时就自动地将我们定义的栈段当作栈空间来访问。
  - 如何使得如`push`、`pop`等栈操作指令访问我们定义的栈段呢？前面我们已经讨论过，就是要将`SS:SP`指向我们定义的栈段。
- 比如我们将 `10010H~1001FH` 这段长度为 16 字节的内存空间当作栈来用，以栈的方式进行访问。
- 这段空间就可以成为栈段，段地址为`1000H`，大小为`16字节`。
- 将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就在执行`push`、`pop`等栈操作指令时就自动地将我们定义的栈段当作栈空间来访问。
- 如何使的如`push`、`pop`等栈操作指令访问我们定义的栈段呢？
    - 将`SS:SP`指向我们定义的栈段。

### 栈段问题 3.11
- 如果我们将`10000H~1FFFFH`这段空间当作栈段，初始状态是空的，此时，`SS=1000H`，`SP=?`

分析：
- 我们将`10000H~1FFFFH`这段空间当作栈段 ，`SS=1000H`，栈空间大小为`64KB` ，栈最底部的字单元地址为`1000:FFFE`。
- 任意时刻，`SS:SP`指向栈顶，当栈中只有一个元素的时候，`SS=1000H`，`SP=FFFEH`。
- 栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2。
- SP原来为FFFEH，加2后SP=0，所以，当栈为空的时候，SS=1000H，SP=0。
- 换个角度看
	- 任意时刻，`SS:SP`指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以`SS:SP`只能指向栈的最底部单元下面的单元，该单元的偏移地址为`栈最底部的字单元的偏移地址+2`，栈最底部字单元的地址为`1000:FFFE`，所以栈空时，`SP=0000H`。

### 栈段问题 3.12
- 一个栈段最大可以设为多少？为什么？

分析：
- 首先从栈操作指令所完成的功能的角度上来看，`push`、`pop`等指令在执行的时候只修改`SP`；
- 所以栈顶的变化范围是`0~FFFFH`，从栈空时候的`SP=0`，一直压栈，直到栈满时`SP=0`；如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。
- 所以一个栈段的容量最大为`64KB`。

### 段的综述
- 我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。
- 我们可以用一个段存放数据，将它定义为**数据段**；
- 我们可以用一个段存放代码，将它定义为**代码段**；
- 我们可以用一个段当作栈，将它定义为**栈段**；
- 我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：
    - 对于数据段，将它的段地址放在 `DS` 中，用`mov`、`add`、`sub`等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据段来访问；
    - 对于代码段，将它的段地址放在 `CS` 中，将段中第一条指令的偏移地址放在`IP`中，这样CPU就将执行我们定义的代码段中的指令；
    - 对于栈段，将它的段地址放在 `SS` 中，将栈顶单元的偏移地置放在 `SP` 中，这样CPU在需要进行栈操作的时候，比如执行 `push`、`pop` 指令等，就将我们定义的栈段当作栈空间来用。
- 可见，不管我们如何安排，
    - CPU 将内存中的某段内存当作代码，是因为 `CS:IP` 指向了那里；
    - CPU 将某段内存当作栈 ，是因为 `SS:SP` 指向了那里。
- 我们一定要清楚 ，什么是我们的安排，以及如何让CPU按我们的安排行事。
- 要非常的清楚CPU的工作机理，才能在控制CPU来按照我们的安排运行的时候做到游刃有余。
- 比如我们将`10000H~1001FH`安排为代码段，并在里面存储如下代码：
```
mov ax,1000H
mov ss,ax
mov sp,0020H  ;初始化栈顶
mov ax,cs
mov ds,ax     ;设置数据段段地址
mov ax,[0]
add ax,[2]
mov bx,[4]
add bx,[6]
push ax
push bx
pop ax
pop bx
```
- 设置`CS=1000H`，`IP=0`，这段代码将得到执行。
- 可以看到，在这段代码中，我们又将`10000H~1001FH`安排为栈段和数据段。
- `10000H~1001FH`这段内存，既是代码段，又是栈段和数据段。
- 一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。
- 关键在于CPU中寄存器的设置，即：
    - `CS`、`IP`、`SS`、`SP`、`DS` 的指向。