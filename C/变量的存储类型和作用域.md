# 局部变量和全局变量

定义变量可能有三种情况：
- 在函数的开头定义
- 在函数内的复合语句内定义
- 在函数的外部定义

局部变量
- 在一个函数内部定义的变量只在本函数范围内有效
- 在复合语句内定义的变量只在本复合语句范围内有效
- 在函数内部或复合语句内部定义的变量称为“局部变量”

全局变量
- 在函数内定义的变量是局部变量，而在函数之外定义的变量称为外部变量
- 外部变量是全局变量(也称全程变量)
- 全局变量可以为本文件中其他函数所共用
- 有效范围为从定义变量的位置开始到本源文件结束

建议不在必要时不要使用全局变量 -> C++ 里解决

```
#include <stdio.h>
int a = 3, b = 5;// p、q 为全局变量
int main()
{
    int max(int a, int b);
    int m, n; // m、n 仅在此函数内有效
    int a = 8; // 冲突时以局部变量为准
    printf("a = %d\nb = %d\n", a, b);
    printf("max = %d\n", max(a, b));
    return 0;
}
int max(int a, int b)
{
    int c;
    c = a > b ? a : b;
    return (c);
}
/*
a = 8
b = 5
max = 8
*/
```

# 动态存储方式与静态存储方式
- 从变量的作用域的角度来观察，变量可以分为全局变量和局部变量
- 从变量值存在的时间(即生存期)观察，变量的存储有两种不同的方式：静态存储方式和动态存储方式
    - 静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式
    - 动态存储方式是在程序运行期间根据需要进行动态的分配存储空间的方式

```
 用　户　区
|＝＝＝＝＝|
|程　序　区|
|－－－－－|
|静态存储区| \
|－－－－－|  } 将数据存放在此区
|动态存储区| /
|＝＝＝＝＝|
```

## 静态存储区
- 程序开始执行时给全局变量分配存储区，程序执行完毕就释放。在程序执行过程中占据固定的存储单元
- 全局变量全部存放在静态存储区中

## 动态存储区
- 函数调用开始时分配，函数结束时释放。在程序执行过程中，这种分配和释放是动态的
1. 函数形式参数
2. 函数中定义的没有用关键字static声明的变量
3. 函数调用时的现场保护和返回地址等存放在动态存储区

# 每一个变量和函数都有两个属性：数据类型和数据的存储类别
- 数据类型，如整型、浮点型等
- 存储类别指的是数据在内存中存储的方式(如静态存储和动态存储)
- 存储类别包括： 自动的、静态的、寄存器的、外部的
- 根据变量的存储类别，可以知道变量的作用域和生存期

# 局部变量的存储类别

## 1. 自动变量(auto变量)
- 局部变量，如果不专门声明存储类别，都是动态地分配存储空间的
- 调用函数时，系统会给局部变量分配存储空间，调用结束时就自动释放空间。因此这类局部变量称为自动变量
- 自动变量用关键字auto作存储类别的声明

```
auto int b, c = 3;
 ↑ 可以省略
```

## 2. 静态局部变量(static局部变量)
希望函数中的局部变量在函数调用结束后不消失而继续**保留原值**，即其占用的存储单元不释放，在下一次再调用该函数时，该变量已有值(就是上一次函数调用结束时的值)，这时就应该指定该局部变量为“静态局部变量”，用关键字**static**进行声明

```
#include <stdio.h>
int main()
{
    int f(int);
    int a = 2, i;
    for (i = 0; i < 3; i++)
        printf("f(a) : %d\n", f(a)); // 调用三次
    return 0;
}
int f(int a)
{
    auto int b = 0;
    static int c = 3;
    b = b + 1;
    c = c + 1;
    printf("a = %d, b = %d, c = %d\n", a, b, c);
    return (a + b + c); // 每调用一次，开辟新a和b，但c不是
}
```

输出：
```
a = 2, b = 1, c = 4
f(a) : 7
a = 2, b = 1, c = 5
f(a) : 8
a = 2, b = 1, c = 6
f(a) : 9
```

## 3. 寄存器变量(register变量)
- 一般情况下，变量（包括静态存储方式和动态存储方式）的值是存放在内存中的
- **寄存器变量**允许将局部变量的值放在CPU中的寄存器中
- 现在的计算机能够识别使用频繁的变量，从而自动地将这些变量放在寄存器中，而不需要程序设计者指定

# 全局变量的存储类别
- 全局变量都是存放在静态存储区中的。因此它们的生存期是固定的，存在于程序的整个运行过程
- 一般来说，外部变量是在函数的外部定义的全局变量，它的作用域是**从变量的定义处开始**，到本程序**文件的末尾**。在此作用域内，全局变量可以为程序中各个函数所引用。

## 1. 在一个文件内扩展外部变量的作用域
- 外部变量有效的作用范围只限于定义处到本文件结束。
- 如果用关键字**extern**对某变量作“外部变量声明”，则可以从“声明”处起，合法地使用该外部变量

```
#include <stdio.h>
int main()
{
    int max();
    extern int A, B, C; // 如果没有外部变量标记 extern，运行结果将是 0
    A = 1, B = 2, C = 3;
    // scanf("%d %d %d", &A, &B, &C);
    printf("max is %d\n", max()); // max is 3
    return 0;
}
int A, B, C;
int max()
{
    int m;
    // m = A;
    // if (m < B) m = B;
    // if (m < C) m = C;
    m = A > B ? A : B; // extern 的变量被使用
    if (C > m)
        m = C;
    return (m);
}
```

## 2. 将外部变量的作用域扩展到其他文件
- 如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量Num，不能分别在两个文件中各自定义一个外部变量Num
- 应在任一个文件中定义外部变量Num，而在另一文件中用**extern**对Num作“外部变量声明”
- 在编译和连接时，系统会由此知道Num有“外部链接”，可以从别处找到已定义的外部变量Num，并将在另一文件中定义的外部变量num的作用域**扩展**到本文件

### a.c:
```
#include <stdio.h>
int A;
int main()
{
    int power(int);
    int b = 3, c, d, m;
    A = 13;
    m = 3;
    // scanf("%d,%d", &A, &m);
    c = A * b;
    printf("%d*%d=%d\n", A, b, c);
    d = power(m);
    printf("%d**%d=%d\n", A, m, d);
    return 0;
}
```
### b.c
```
extern int A;
int power(int n)
{
    int i, y = 1;
    for (i = 1; i <= n; i++)
        y *= A;
    return (y);
}
```
### gcc a.c b.c -o a.out && ./a.out
```
13*3=39
13**3=2197
```

## 3.将外部变量的作用域限制在本文件中
有时在程序设计中希望某些外部变量只限于被本文件引用。这时可以在定义外部变量时加一个static声明。

file1.c:
`static int A; // 只能用于本文件`

file2.c
`extern A; // 本文件仍然不能用`

### 说明:
- 不要误认为对外部变量加static声明后才采取静态存储方式，而不加static的是采取动态存储
- 声明局部变量的存储类型和声明全局变量的存储类型的含义是不同的
- 对于**局部变量**来说，声明存储类型的作用是指定变量存储的区域以及由此产生的生存期的问题，而对于**全局变量**来说，声明存储类型的作用是变量作用域的扩展问题

### 用static 声明一个变量的作用是：
1. 对**局部变量**用static声明，把它分配在静态存储区，该变量在整个程序执行期间不释放，其所分配的空间始终存在。
2. 对**全局变量**用static声明，则该变量的作用域只限于本文件模块(即被声明的文件中)。

### 注意：
- 用`auto`、`register`、`static`声明变量时，是在定义变量的基础上加上这些关键字，而不能单独使用。
- 下面用法不对：
```
int a;
static a; // 编译时会被认为“重新定义”。
```

# 存储类别

## 对一个数据的定义，需要指定两种属性：
- 数据类型和存储类别，分别使用两个关键字。例如：
    - `static int a; // 静态局部整型变量或静态外部整型变量`
    - `auto char c; // 自动变量，在函数内定义`
    - `register int d; // 寄存器变量，在函数内定义`
- 可以用extern声明已定义的外部变量。例如：
    - `extern b; // 将已定义的外部变量b的作用域扩展至此`

## 1. 从作用域角度分，有局部变量和全局变量。
它们采用的存储类别如下：

- 按作用域角度分
    - 局部变量（形式参数可以定义为自动变量或寄存器变量）
        - 自动变量
        - 静态局部变量
        - 寄存器变量
    - 全局变量
        - 静态外部变量
        - 外部变量

## 2. 从变量存在的时间区分,有动态存储和静态存储两种类型。
静态存储是程序整个运行时间都存在，而动态存储则是在调用函数时临时分配单元。

- 按生存期分
    - 动态存储
        - 自动变量
        - 寄存器变量
        - 形式参数
    - 静态存储
        - 静态局部变量
        - 静态外部变量
        - 外部变量

## 3. 从变量值存放的位置来区分
可分为:

- 按变量值存放的位置分
    - 内存中静态存储区
        - 静态局部变量
        - 静态外部变量
        - 外部变量
    - 内存中动态存储区
        - 自动变量
        - 形式参数
    - CPU中的寄存器
        - 寄存器变量

## 4. 关于作用域和生存期的概念

- 对一个变量的属性可以从两个方面分析：
    - 作用域：如果一个变量在某个文件或函数范围内是有效的，就称该范围为该变量的**作用域**
    - 生存期：如果一个变量值在某一时刻是存在的，则认为这一时刻属于该变量的**生存期**
- 作用域是从**空间**的角度，生存期是从**时间**的角度
- 二者有联系但不是同一回事

## 作用域
```
int a;                        + a的
int main( )                   |  作
{                             |  用
    ...f2( );                 |  域
    ...f1( );                 |
    ...                       |
}                             |
void f1( )                    |
{                             |
    auto int b;            +  |  b的
    ...                    |  |   作
    f2( );                 |  |   用
    ...                    |  |   域
}                             |
void f2( )                    |
{                             |
    static int c;          +  |  c的作
    ...                    |  |   用域
}                             |
```

### 程序执行过程
```
main -> f2 -> main -> f1 -> f2 -> f1 -> main
|<---------------------------------------->| a 生存期
                    |<--->|     |<--->|      b 生存期
|<---------------------------------------->| c 生存期
```

### 各种类型变量的作用域和存在性的情况

| 　　变量存储类别　　 | 函数内作用域 | 函数内存在性 | 函数外作用域 | 函数外存在性 |
| :------------------: | :----------: | :----------: | :----------: | :----------: |
| 自动变量和寄存器变量 | 　ＴＲＵＥ　 | 　ＴＲＵＥ　 |  ＦＡＬＳＥ  |  ＦＡＬＳＥ  |
| 　　静态局部变量　　 | 　ＴＲＵＥ　 | 　ＴＲＵＥ　 |  ＦＡＬＳＥ  | 　ＴＲＵＥ　 |
| 　　静态外部变量　　 | 　ＴＲＵＥ　 | 　ＴＲＵＥ　 | 只限本文件 | 　ＴＲＵＥ　 |
| 　　　外部变量　　　 | 　ＴＲＵＥ　 | 　ＴＲＵＥ　 | 　ＴＲＵＥ　 | 　ＴＲＵＥ　 |

## 5. static对局部变量和全局变量的作用不同
- 局部变量使变量由动态存储方式改变为静态存储方式
- 全局变量使变量局部化(局部于本文件)，但仍为静态存储方式
- 从作用域角度看，凡有static声明的，其作用域都是局限的，或者是局限于本函数内(静态局部变量)，或者局限于本文件内(静态外部变量)

# 关于变量的声明和定义
- 一般为了叙述方便，把建立存储空间的变量声明称**定义**，而把不需要建立存储空间的声明称为**声明**
- 在函数中出现的对变量的声明(除了用extern声明的以外)都是定义
- 在函数中对其他函数的声明不是函数的定义

## 内部函数
- 如果一个函数只能被本文件中其他函数所调用，它称为**内部函数**。
- 在定义内部函数时，在函数名和函数类型的前面加static，即:
    - `static 类型名 函数名(形参表)`
- 内部函数又称静态函数，因为它是用static声明的
- 通常把只能由本文件使用的函数和外部变量放在文件的开头，前面都冠以static使之局部化，其他文件不能引用
- 提高了程序的可靠性

## 外部函数
- 如果在定义函数时，在函数首部的最左端加关键字extern，则此函数是**外部函数**，可供其他文件调用。
- 如函数首部可以为
    - `extern int fun (int a, int b)`
- 如果在定义函数时省略extern，则默认为外部函数

## 例
- 有一个字符串，内有若干个字符，今输入一个字符，要求程序将字符串中该字符删去。用外部函数实现。
- 解题思路：
    - 分别定义3个函数用来输入字符串、删除字符、输出字符串
    - 按题目要求把以上3个函数分别放在3个文件中。main函数在另一文件中，main函数调用以上3个函数，实现题目的要求
- 删除空格的思路：
```
i = 10 : I am happy\0...
j =  8 : Iamhappy\0y\0...
```

### 文件1
```
#include <stdio.h>
int main()
{
    // 声明在本函数中将要调用的已在其他文件中定义的3个函数
    extern void enter_string(char str[]);
    extern void delete_string(char str[], char ch);
    extern void print_string(char str[]);
    char c, str[80];
    enter_string(str);
    scanf("%c", &c);
    delete_string(str, c);
    print_string(str);
    return 0;
}
```

### 文件2
```
void enter_string(char str[80])
{
    gets(str);
}
```

### 文件3
```
void delete_string(char str[], char ch)
{
    int i, j;
    for (i = j = 0; str[i] != '\0'; i++)
        if (str[i] != ch)
            str[j++] = str[i];
    str[j] = '\0';
}
```

### 文件4
```
void print_string(char str[])
{
    printf("%s\n", str);
}
```